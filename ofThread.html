<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ofThread</title>

  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
  <link rel="stylesheet" href="stylesheet.css">

  <!-- Optional theme -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap-theme.min.css">


  <link href="http://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet" type="text/css">

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>
<body>


<nav class="navbar navbar-fixed-top header" role="navigation">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <a class="navbar-brand" href="index.html">ofDoc</a>
    </div>


    <div class="navbar-form navbar-right" role="search">
      <div class="form-group">
        <input type="text" class="form-control" placeholder="Search" id="search" autocomplete="off">
      </div>
      <ul class="searchResult hidden"></ul>

    </div>


  </div>
</nav>


<div class="container">
    <div class="quicknav">
      <a href="index.html">ofDoc</a> &gt; <a id="categoryQuickNav">utils</a> &gt; <span id="classQuickNav">ofThread</span>
    </div>

  <nav class="navigator" role="navigation">
    <ul id="nav-parts">
      <li class="group selected">
        Topics
        <ul id="topics">
        <span class="class">ofThread</span><li class="chapter"><a href="#Types">Types</a></li><li class="chapter"><a href="#Functions">Functions</a></li><li class="chapter"><a href="#StaticFunctions">Static Functions</a></li></ul>
    </li></ul>
  </nav>
  <div class="main">
    <div class="content">

    <div id="" class="classBlock">
    <div class="classHeader">
      <h1 class="classTitle">ofThread<small>file</small></h1>
    </div>
    <div class="classDescription"></div>
    <div class="classMethods"></div>
  </div><div id="" class="classBlock">
    <div class="classHeader">
      <h1 class="classTitle">ofThread<small>class</small></h1>
    </div>
    <div class="classDescription"><div class="textblock"><p>A threaded base class with a built in mutex for convenience. </p>
<p>Users can extend this base class by public inheritance like this: </p>
<pre class="fragment">class MyThreadedClass: public ofThread
{
    public:
    /// ...
    void threadedFunction()
    {
        while(isThreadRunning())
        {
            /// Threaded function here.
        }
    }
};
</pre><p><a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> is a convenient wrapper for Poco::Thread, Poco::Runnable and Poco::Mutex. It represents a simplified (sometimes overly simplified - or simplified in ways that might not make sense for your project) pathway for quickly writing threaded classes. Poco::Runnable represents a class that can be &quot;run&quot; via its void run() method. Poco::Thread is able to spawn a thread and &quot;run&quot; the contents of a class that extends the Poco::Runnable interface (which <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> does). Poco::FastMutex, (aka ofMutex) is a &quot;mutual exclusion&quot; object that prevents two threads from accessing the same data at the same time. It is important to know that Poco::FastMutex (aka ofMutex) is not &quot;recursive&quot; while Poco::Mutex is. This means that if the same thread attempts to lock a thread while it ALREADY has a lock on the mutex, the program will lock up and go nowhere. Thus, it is important that <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclasses carefully their use of the mutex. Currently <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> does not lock its own mutex at any point (e.g. <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>&apos;s internal variables are not thread safe). This is a somewhat dangerous convenience that is (theoretically) supposed to make it easier for subclasses to avoid the recursive mutex &quot;problem&quot;. The situation that arises from two threads simultanously reading or writing from the same shared data (shared data occupies the same physical location in memory) leads to something called a &quot;race condition&quot;, which can lead to deadlocks. A deadlock is as bad as it sounds. It means your program just stops. ofMutex prevents race conditions, deadlocks and crashes by permitting only one thread access to shared data at a time. When using mutexes to protect data, the trick is to always be sure to unlock the mutex when finished. This problem can often be avoided by using an Poco::FastMutex::ScopedLock (aka ofScopedLock). See the the documentation for more information. Finally, there are many cases where it might make more sense to use Poco::Thread, Poco::Runnable and Poco::FastMutex directly rather than using <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>. Further, cross platform thread management will be alleviated with the std::thread support library included with C++11.</p>
<p>Uncaught Exceptions throw from within <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> will cause the thread to stop and the Exception will be delivered to the default ofBaseThreadErrorHandler. The ofBaseThreadErrorHandler will print the exception details, if available. The ofBaseThreadErrorHandler offers no opportunity to take corrective action and only allows the user to receive more valuable debugging information about the uncaught exception. Users should design <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclasses to catch and respond to all anticipated exceptions. </p>
</div></div>
    <div class="classMethods"><div id="Types">
    <h3 class="sectionHeader">Types</h3>
    <div class="sectionDescription"></div>
    <div class="sectionContent"><div id="a73e55750cdbed68d45a0ba9e7d391c4a" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a73e55750cdbed68d45a0ba9e7d391c4a&quot;)">
        <span class="type"></span>
        <a class="name">Anonymous enum</a>
        <span class="args"></span>
        <span class="kind">enum</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a73e55750cdbed68d45a0ba9e7d391c4a_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type"> </span><span class="name">Anonymous enum</span><span class="args"></span></div><div class="memberDocumentation">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a73e55750cdbed68d45a0ba9e7d391c4aacd7c0f12a26a642772db642e8862e98e"></a>INFINITE_JOIN_TIMEOUT</em>&#xA0;</td><td class="fielddoc">
<p>A sentinal value for an infinite join timeout. </p>
<p>Primarily used with the <a class="el" href="ofThread.html#a4faefa778ff5338ee7add57dd5ec2a5f" title="Wait for the thread to exit (aka &quot;joining&quot; the thread). ">waitForThread()</a> method. </p>
</td></tr>
</table>

</div></div>
  </div></div>
  </div><div id="Functions">
    <h3 class="sectionHeader">Functions</h3>
    <div class="sectionDescription"></div>
    <div class="sectionContent"><div id="a6e9afd83f8dd763f7230d13286611a9c" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a6e9afd83f8dd763f7230d13286611a9c&quot;)">
        <span class="type"></span>
        <a class="name">ofThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a6e9afd83f8dd763f7230d13286611a9c_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type"> </span><span class="name">ofThread</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Create an <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>. </p>

</div></div>
  </div><div id="a8faffc9621a184465b9fdfef0b36b2fd" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a8faffc9621a184465b9fdfef0b36b2fd&quot;)">
        <span class="type"></span>
        <a class="name">~ofThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a8faffc9621a184465b9fdfef0b36b2fd_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type"> </span><span class="name">~ofThread</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Destroy the <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The destructor WILL NOT stop the thread or wait for the underlying Poco::Thread to finish. For threads that require the correct deallocation of resources, the user MUST call waitForThread(...); to ensure that the thread is stopped and the thread&apos;s resources are released. Improper release of resources or memory can lead to segementation faults and other errors. </dd></dl>

</div></div>
  </div><div id="a07a51505ea9f5407e8c5999368bd54e2" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a07a51505ea9f5407e8c5999368bd54e2&quot;)">
        <span class="type"></span>
        <a class="name">isThreadRunning</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a07a51505ea9f5407e8c5999368bd54e2_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">bool </span><span class="name">isThreadRunning</span><span class="args">() const </span></div><div class="memberDocumentation">

<p>Check the running status of the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff the thread is currently running. </dd></dl>

</div></div>
  </div><div id="a03c3de0a6eafba5ace00150e0ba39e8e" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a03c3de0a6eafba5ace00150e0ba39e8e&quot;)">
        <span class="type"></span>
        <a class="name">getThreadId</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a03c3de0a6eafba5ace00150e0ba39e8e_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">int </span><span class="name">getThreadId</span><span class="args">() const </span></div><div class="memberDocumentation">

<p>Get the unique thread id. </p>
<dl class="section note"><dt>Note</dt><dd>This is NOT the the same as the operating thread id! </dd></dl>

</div></div>
  </div><div id="aa9f277270d8f1220397ce78b7abdbf46" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#aa9f277270d8f1220397ce78b7abdbf46&quot;)">
        <span class="type"></span>
        <a class="name">getThreadName</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="aa9f277270d8f1220397ce78b7abdbf46_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">std::string </span><span class="name">getThreadName</span><span class="args">() const </span></div><div class="memberDocumentation">

<p>Get the unique thread name, in the form of &quot;Thread id#&quot;. </p>
<dl class="section return"><dt>Returns</dt><dd>the Thread ID string. </dd></dl>

</div></div>
  </div><div id="a46295f96e3730f6449adca48426c967e" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox deprecatedMethod" onClick="toggleDescription(&quot;#a46295f96e3730f6449adca48426c967e&quot;)">
        <span class="type"></span>
        <a class="name">startThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note">Use startThread(bool blocking = true) instead.</span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a46295f96e3730f6449adca48426c967e_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">void </span><span class="name">startThread</span><span class="args">(bool mutexesBlock, bool verbose)</span></div><div class="memberDocumentation">

<p>Start the thread with options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexesBlock</td><td>Set blocking to true if you want the mutex to block when <a class="el" href="ofThread.html#a8b682673b3d11225785b74f68fc3ce96" title="Try to lock the mutex. ">lock()</a> is called. </td></tr>
    <tr><td class="paramname">verbose</td><td>use verbose logging methods. </td></tr>
  </table>
  </dd>
</dl>

</div><hr><div class="memberVariant"><span class="type">void </span><span class="name">startThread</span><span class="args">(bool mutexBlocks=true)</span></div><div class="memberDocumentation">

<p>Start the thread with options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexBlocks</td><td>Set blocking to true if you want the mutex to block when <a class="el" href="ofThread.html#a8b682673b3d11225785b74f68fc3ce96" title="Try to lock the mutex. ">lock()</a> is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Subclasses can directly access the mutex and employ thier own locking strategy. </dd></dl>

</div></div>
  </div><div id="a8b682673b3d11225785b74f68fc3ce96" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a8b682673b3d11225785b74f68fc3ce96&quot;)">
        <span class="type"></span>
        <a class="name">lock</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a8b682673b3d11225785b74f68fc3ce96_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">bool </span><span class="name">lock</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Try to lock the mutex. </p>
<p>If the thread was started startThread(true), then this call will wait until the mutex is available and return true. If the thread was started startThread(false), this call will return true iff the mutex is was successfully acquired.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff the lock was successfully acquired. </dd></dl>

</div></div>
  </div><div id="a98fd09fe1a8db65c2444abab0e806831" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a98fd09fe1a8db65c2444abab0e806831&quot;)">
        <span class="type"></span>
        <a class="name">unlock</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a98fd09fe1a8db65c2444abab0e806831_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">void </span><span class="name">unlock</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Unlock the mutex. </p>
<p>This will only unlocks the mutex if it was previously by the same calling thread. </p>

</div></div>
  </div><div id="a3102a3bf7897f579d70a418ae3ed010b" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a3102a3bf7897f579d70a418ae3ed010b&quot;)">
        <span class="type"></span>
        <a class="name">stopThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a3102a3bf7897f579d70a418ae3ed010b_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">void </span><span class="name">stopThread</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Stop the thread. </p>
<p>This does immediately stop the thread from processing, but will only set a flag that must be checked from within your threadedFunction() by calling <a class="el" href="ofThread.html#a07a51505ea9f5407e8c5999368bd54e2" title="Check the running status of the thread. ">isThreadRunning()</a>. If the user wants to both stop the thread AND wait for the thread to finish processing, the user should call waitForThread(true, ...). </p>

</div></div>
  </div><div id="a4faefa778ff5338ee7add57dd5ec2a5f" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a4faefa778ff5338ee7add57dd5ec2a5f&quot;)">
        <span class="type"></span>
        <a class="name">waitForThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a4faefa778ff5338ee7add57dd5ec2a5f_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">void </span><span class="name">waitForThread</span><span class="args">(bool callStopThread=true, long milliseconds=INFINITE_JOIN_TIMEOUT)</span></div><div class="memberDocumentation">

<p>Wait for the thread to exit (aka &quot;joining&quot; the thread). </p>
<p>This method waits for a thread will &quot;block&quot; and wait for the thread (aka &quot;join&quot; the thread) before it returns. This allows the user to be sure that the thread is properly cleaned up. An example of when this might be particularly important is if the threadedFunction() is opening a set of network sockets, or downloading data from the web. Destroying an <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclass without releasing those sockets (or other resources), may result in segmentation faults, error signals or other undefined behaviors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callStopThread</td><td>Set stop to true if you want to signal the thread to exit before waiting. This is the equivalent to calling <a class="el" href="ofThread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a>. If you your threadedFunction uses a while-loop that depends on <a class="el" href="ofThread.html#a07a51505ea9f5407e8c5999368bd54e2" title="Check the running status of the thread. ">isThreadRunning()</a> and you do not call <a class="el" href="ofThread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a> or set stop == true, waitForThread will hang indefinitely. Set stop == false ONLY if you have already called <a class="el" href="ofThread.html#a3102a3bf7897f579d70a418ae3ed010b" title="Stop the thread. ">stopThread()</a> and you simply need to be sure your thread has finished its tasks.</td></tr>
    <tr><td class="paramname">milliseconds</td><td>If millseconds is set to INFINITE_JOIN_TIMEOUT, the waitForThread will wait indefinitely for the thread to complete. If milliseconds is set to a lower number (e.g. 10000 for 10 seconds), waitForThread will wait for 10000 milliseconds and if the thread has not yet stopped it will return and log an error message. Users are encouraged to use the default INFINITE_JOIN_TIMEOUT. If the user is unhappy with the amount of time it takes to join a thread, the user is encouraged to seek more expedient ways of signalling their desire for a thread to complete via other signalling methods such as Poco::Event, Poco::Condition, or Poco::Semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://pocoproject.org/slides/090-NotificationsEvents.pdf">http://pocoproject.org/slides/090-NotificationsEvents.pdf</a> </dd>
<dd>
<a href="http://pocoproject.org/docs/Poco.Condition.html">http://pocoproject.org/docs/Poco.Condition.html</a> </dd>
<dd>
<a href="http://pocoproject.org/docs/Poco.Event.html">http://pocoproject.org/docs/Poco.Event.html</a> </dd>
<dd>
<a href="http://pocoproject.org/docs/Poco.Semaphore.html">http://pocoproject.org/docs/Poco.Semaphore.html</a> </dd></dl>

</div></div>
  </div><div id="a9e99dc383aba491a664efad32d2d7ccb" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a9e99dc383aba491a664efad32d2d7ccb&quot;)">
        <span class="type"></span>
        <a class="name">sleep</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a9e99dc383aba491a664efad32d2d7ccb_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">void </span><span class="name">sleep</span><span class="args">(long milliseconds)</span></div><div class="memberDocumentation">

<p>Tell the thread to sleep for a certain amount of milliseconds. </p>
<p>This is useful inside the threadedFunction() when a thread is waiting for input to process: </p>
<pre class="fragment">void MyThreadedClass::threadedFunction()
{
    // start
    while(isThreadRunning())
    {
        // bReadyToProcess can be set from outside the threadedFuntion.
        // perhaps by another thread that downloads data, or loads
        // some media, etc.

        if(bReadyToProcess == true)
        {
            // do some time intensive processing
            bReadyToProcess = false;
        }
        else
        {
            // sleep the thread to give up some cpu
            sleep(20);
        }
    }
    // done
}
</pre><p>If the user does not give the thread a chance to sleep, the thread may take 100% of the CPU core while it&apos;s looping as it waits for something to do. This may lead to poor application performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div></div>
  </div><div id="a35bf3cab66dc5dda34b172784b401003" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a35bf3cab66dc5dda34b172784b401003&quot;)">
        <span class="type"></span>
        <a class="name">yield</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a35bf3cab66dc5dda34b172784b401003_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">void </span><span class="name">yield</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Tell the thread to give up its CPU time other threads. </p>
<p>This method is similar to <a class="el" href="ofThread.html#a9e99dc383aba491a664efad32d2d7ccb" title="Tell the thread to sleep for a certain amount of milliseconds. ">sleep()</a> and can often be used in the same way. The main difference is that 1 millisecond (the minimum sleep time available with <a class="el" href="ofThread.html#a9e99dc383aba491a664efad32d2d7ccb" title="Tell the thread to sleep for a certain amount of milliseconds. ">sleep()</a>) is a very long time on modern processors and <a class="el" href="ofThread.html#a35bf3cab66dc5dda34b172784b401003" title="Tell the thread to give up its CPU time other threads. ">yield()</a> simply gives up processing time to the next thread, instead of waiting for number of milliseconds. In some cases, this behavior will be preferred. </p>

</div></div>
  </div><div id="a96b7892fb6c0ddda7fe046aaa019da90" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a96b7892fb6c0ddda7fe046aaa019da90&quot;)">
        <span class="type"></span>
        <a class="name">isCurrentThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a96b7892fb6c0ddda7fe046aaa019da90_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">bool </span><span class="name">isCurrentThread</span><span class="args">() const </span></div><div class="memberDocumentation">

<p>Query whether the current thread is active. </p>
<p>In multithreaded situations, it can be useful to know which thread is currently running some code in order to make sure only certain threads can do certain things. For example, OpenGL can only run in the main execution thread. Thus, situations where a thread is responsible for interacting with graphics resources may need to prevent graphics updates unless the main thread is accessing or updating resources shared with this <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> (or its subclass). </p>
<pre class="fragment">if(myThread.isCurrentThread())
{
    // do some myThread things,
    // but keep your hands off my resources!
}
else if(ofThread::isMainThread())
{
    // pheew! ok, update those graphics resources
}
</pre><p>By way of another example, a subclass of <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> may have an update() method that is called from <a class="el" href="ofBaseApp.html">ofBaseApp</a> during the execution of the main application thread. In these cases, the <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> subclass might want to ask itself whether it can, for instance, call update() on an ofImage, in order to send copy some ofPixels to an <a class="el" href="ofTexture.html" title="A wrapper class for an OpenGL texture. ">ofTexture</a> on the graphics card.</p>
<dl class="section return"><dt>Returns</dt><dd>True iff this <a class="el" href="ofThread.html" title="A threaded base class with a built in mutex for convenience. ">ofThread</a> the currently active thread. </dd></dl>

</div></div>
  </div><div id="a3b607a4239526df49fb23738453645ef" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a3b607a4239526df49fb23738453645ef&quot;)">
        <span class="type"></span>
        <a class="name">getPocoThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a3b607a4239526df49fb23738453645ef_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">Poco::Thread &amp; </span><span class="name">getPocoThread</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Get a reference to the underlying Poco thread. </p>
<p>Poco::Thread provides a clean cross-platform wrapper for threads. On occasion, it may be useful to interact with the underlying Poco::Thread directly.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the backing Poco thread. </dd></dl>

</div><hr><div class="memberVariant"><span class="type">const Poco::Thread &amp; </span><span class="name">getPocoThread</span><span class="args">() const </span></div><div class="memberDocumentation">

<p>Get a const reference to the underlying Poco thread. </p>
<p>Poco::Thread provides a clean cross-platform wrapper for threads. On occasion, it may be useful to interact with the underlying Poco::Thread directly.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the backing Poco thread. </dd></dl>

</div></div>
  </div><div id="a49beba601eef1f31fe733fd0e5647f2b" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox deprecatedMethod" onClick="toggleDescription(&quot;#a49beba601eef1f31fe733fd0e5647f2b&quot;)">
        <span class="type"></span>
        <a class="name">getCurrentThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note">use ofThread::getCurrentPocoThread() == &amp;yourThread.getPocoThread() to compare threads.</span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a49beba601eef1f31fe733fd0e5647f2b_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">static ofThread </span><span class="name">getCurrentThread</span><span class="args">()</span></div><div class="memberDocumentation">

</div></div>
  </div></div>
  </div><div id="StaticFunctions">
    <h3 class="sectionHeader">Static Functions</h3>
    <div class="sectionDescription"></div>
    <div class="sectionContent"><div id="a23f292adedaad5a0991637a1746d9772" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a23f292adedaad5a0991637a1746d9772&quot;)">
        <span class="type"></span>
        <a class="name">isMainThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a23f292adedaad5a0991637a1746d9772_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">bool </span><span class="name">isMainThread</span><span class="args">()</span></div><div class="memberDocumentation">

<p>A query to see if the current thread is the main thread. </p>
<p>Some functions (e.g. OpenGL calls) can only be executed the main thread. This static function will tell the user what thread is currently active at the moment the method is called. </p>
<pre class="fragment">if (ofThread::isMainThread())
{
    ofLogNotice() &lt;&lt; &quot;This is the main thread!&quot;;
}
else
{
    ofLogNotice() &lt;&lt; &quot;This is NOT the main thread.&quot;;
}
</pre><dl class="section return"><dt>Returns</dt><dd>true iff the current thread is the main thread. </dd></dl>

</div></div>
  </div><div id="a4060c79bf667e0ad2fbe78e7d12c2905" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox" onClick="toggleDescription(&quot;#a4060c79bf667e0ad2fbe78e7d12c2905&quot;)">
        <span class="type"></span>
        <a class="name">getCurrentPocoThread</a>
        <span class="args"></span>
        <span class="kind">()</span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none" id="a4060c79bf667e0ad2fbe78e7d12c2905_description"> <!-- Description goes here --> <div class="memberVariant"><span class="type">Poco::Thread * </span><span class="name">getCurrentPocoThread</span><span class="args">()</span></div><div class="memberDocumentation">

<p>Get the current Poco thread. </p>
<p>In most cases, it is more appropriate to query the current thread by calling <a class="el" href="ofThread.html#a96b7892fb6c0ddda7fe046aaa019da90" title="Query whether the current thread is active. ">isCurrentThread()</a> on an active thread or by calling <a class="el" href="ofThread.html#a23f292adedaad5a0991637a1746d9772" title="A query to see if the current thread is the main thread. ">ofThread::isMainThread()</a>. See the method documentation for more information on those methods.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the current active thread OR 0 iff the main application thread is active. </dd></dl>

</div></div>
  </div></div>
  </div></div>
  </div></div>
  </div>

</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.7.0/underscore-min.js"></script>

<script src="script.js"></script>
<script src="fuse.min.js"></script>
<script src="toc.js"></script>
<script src="search.js"></script>

</body>

<!-- Templates - These are being used by the generator script -->
<div id="templates">

  <!-- Class template -->
  <div id="classTemplate" class="classBlock">
    <div class="classHeader">
      <h1 class="classTitle"></h1>
    </div>
    <div class="classDescription"></div>
    <div class="classMethods"></div>
  </div>

  <!-- Section template -->
  <div id="sectionTemplate">
    <h3 class="sectionHeader"></h3>
    <div class="sectionDescription"></div>
    <div class="sectionContent"></div>
  </div>

  <!-- Class method template -->
  <div id="classMethodTemplate" class="method">
    <div class="methodHeader">
      <div class="methodHeaderBox">
        <span class="type"></span>
        <a class="name"></a>
        <span class="args"></span>
        <span class="kind"></span>
        <span class="note"></span>
      </div>
    </div>

    <div class="methodDescription" style="display:none"> <!-- Description goes here --> </div>
  </div>

</div>

</html>